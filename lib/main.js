// Generated by CoffeeScript 1.7.1
(function() {
  var BITSNPIECES, TRM, TYPES, alert, badge, debug, echo, help, info, log, njs_fs, njs_path, rpr, warn, whisper,
    __slice = [].slice;

  njs_fs = require('fs');

  njs_path = require('path-extra');

  TYPES = require('coffeenode-types');

  TRM = require('coffeenode-trm');

  rpr = TRM.rpr.bind(TRM);

  badge = 'OPTIONS';

  log = TRM.get_logger('plain', badge);

  info = TRM.get_logger('info', badge);

  whisper = TRM.get_logger('whisper', badge);

  alert = TRM.get_logger('alert', badge);

  debug = TRM.get_logger('debug', badge);

  warn = TRM.get_logger('warn', badge);

  help = TRM.get_logger('help', badge);

  echo = TRM.echo.bind(TRM);

  BITSNPIECES = require('coffeenode-bitsnpieces');

  this._app_name_from_home = function(app_home) {
    return njs_path.basename(app_home);
  };

  this._cndid_from_app_name = function(app_name) {
    var R;
    if (!/^coffeenode-.+$/.test((R = app_name))) {
      return R;
    }
    R = R.replace(/^coffeenode-/, '');
    R = R.replace(/-/g, '/');
    return R.toUpperCase();
  };

  this.get_app_info = function(app_home, options_filename) {
    var R, app_name, cndid, options_route;
    if (app_home == null) {
      app_home = null;
    }
    if (options_filename == null) {
      options_filename = null;
    }
    if (app_home == null) {
      app_home = BITSNPIECES.get_app_home();
    }
    app_name = this._app_name_from_home(app_home);
    cndid = this._cndid_from_app_name(app_name);
    options_route = njs_path.join(app_home, options_filename != null ? options_filename : 'options.json');
    R = {
      '~isa': 'OPTIONS/app-info',
      'user-home': njs_path.homedir(),
      'home': app_home,
      'name': app_name,
      'cndid': cndid,
      'options-route': options_route
    };
    return R;
  };

  this._load = function(name, route) {
    var code, error, source;
    try {
      source = njs_fs.readFileSync(route, {
        encoding: 'utf-8'
      });
    } catch (_error) {
      error = _error;
      switch (code = error['code']) {
        case 'ENOENT':
          alert("\nunable to load " + name + " from \n  " + route + "\n");
          break;
        case 'EACCES':
          alert("\ninsufficient rights to load " + name + " from \n  " + route + "\n");
          break;
        default:
          alert("\nan error occurred when trying to load " + name + " from \n  " + route + "\n");
      }
      throw error;
    }
    try {
      return JSON.parse(source);
    } catch (_error) {
      error = _error;
      alert("\nan error occurred when trying to parse " + name + " from file \n  " + route + "\n");
      throw error;
    }
  };

  this._module_name_from_options_filename = function(options_filename) {
    var matcher;
    matcher = /^([^\/]+)-options.json$/;
    if (!matcher.test(options_filename)) {
      throw new Error("this does not look like a valid module options filename: " + (rpr(options_filename)));
    }
    return options_filename.replace(matcher, '$1');
  };

  this.get_app_options = function() {
    var R, app_info, options_route, raw_options;
    app_info = this.get_app_info();
    options_route = app_info['options-route'];
    raw_options = this._load('options', options_route);
    R = {
      '~isa': 'OPTIONS/options',
      'app-info': app_info
    };
    return R;
  };

  this.compile = function(source, options) {
    var change_count;
    change_count = 0;
    return BITSNPIECES.walk_containers_crumbs_and_values(d, (function(_this) {
      return function(error, container, crumbs, value) {
        var head, key, _i;
        if (error != null) {
          throw error;
        }
        if (crumbs === null) {
          return;
        }
        head = 2 <= crumbs.length ? __slice.call(crumbs, 0, _i = crumbs.length - 1) : (_i = 0, []), key = crumbs[_i++];
        log("" + locator + ":", rpr(value));
        if (key === 'box') {
          container['addition'] = 'yes!';
          return debug(container);
        }
      };
    })(this));
  };

  this.compile_options = function(options) {
    var count_key, name, type, value;
    TYPES = require('coffeenode-types');
    count_key = this.compile_options.count_key;
    if (options[count_key] == null) {
      options[count_key] = 0;
    }
    for (name in options) {
      value = options[name];
      switch (type = TYPES.type_of(value)) {
        case 'text':
          this.compile_options.resolve_name.call(this, options, null, name, value);
          break;
        case 'pod':
          null;
          break;
        case 'list':
          null;
      }
    }
    return options;
  };

  this.compile_options.count_key = '%BITSNPIECES/compile-options/change-count';

  this.compile_options.no_name_re = /^\\\$/;

  this.compile_options.name_re = /^\$([-_a-zA-Z0-9]+)$/;

  this.compile_options.resolve_name = function(options, container, key, value) {
    var count_key, match, new_name, new_value;
    rpr = (require('util')).inspect;
    count_key = this.compile_options.count_key;
    if (container == null) {
      container = options;
    }
    if ((match = value.match(this.compile_options.name_re)) != null) {
      new_name = match[1];
      new_value = options[new_name];
      if (new_value === void 0) {
        throw new Error("member " + (rpr(key)) + " references undefined key as " + (rpr(value)));
      }
      container[key] = new_value;
      options[count_key] += 1;
      debug("replaced " + (rpr(key)) + ": " + (rpr(value)) + " with " + (rpr(new_name)) + ": " + (rpr(new_value)));
    } else {
      new_value = value.replace(this.compile_options.no_name_re, '$');
      container[key] = new_value;
      if (value !== new_value) {
        options[count_key] += 1;
        debug("replaced " + (rpr(value)) + " with " + (rpr(new_value)));
      }
    }
    return options;
  };

}).call(this);
